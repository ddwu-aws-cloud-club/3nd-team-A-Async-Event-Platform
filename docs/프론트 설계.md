본 시스템은 **중복 참여 방지와 요청 추적의 정확성**을 위해

**로그인 기반 참여 방식**만을 지원한다.

> 비동기 처리 특성상 “요청은 즉시 처리되지 않으며,
> 
> 
> 사용자는 요청 ID(requestId)를 통해 자신의 요청 상태를 추적한다.”
> 

## A. 사용자(User) 화면 — **5개**

### 1) 랜딩 / 이벤트 목록
목적
: 사용자가 “이 이벤트는 즉시 결과가 나오지 않는 비동기 처리”임을 참여 전에 인지하도록 한다.

- 진행 중 이벤트 카드
    - 이벤트명
    - 방식: `FIRST_COME` / `LOTTERY`
    - 정원 또는 마감 시각
    - 상태: 오픈 / 마감 / 결과 발표
- CTA: **[참여하기]**

설계 의도

> 비동기 처리 이벤트임을 사전에 인지시키기 위해
> 
> 
> **이벤트 방식(FIRST_COME / LOTTERY)을 명확히 노출**
> 
> 한다.
> 

---

### 2️) 이벤트 상세 / 참여 화면 (**핵심 UX**)
### 주요 원칙
- 참여 버튼은 1개이며, 클릭 후 서버 응답이 202여도 “처리 완료”가 아니라 **“접수 완료”**임을 명확히 안내
- 참여 전 안내 문구
- 중복 참여가 감지되면 버튼 비활성화 + “이미 신청됨” 메시지를 노출

### 참여 버튼 클릭 직후 UX (202 Accepted)

-  **“접수 완료” 토스트**
- requestId 표시 + 복사 버튼
- 버튼 비활성화
    - “이미 신청된 이벤트입니다”
- **상태 전이 UI (타임라인 / 스텝퍼)**

> 202 Accepted 응답은 “처리 완료”가 아닌
**“요청이 안전하게 접수되었음”을 의미**함을 명확히 한다.
> 

---

### 상태 타임라인 (방식별 분리)

**FIRST_COME**

```
접수 완료 → 대기열 등록 → 처리 중 → 결과 확정

```

**LOTTERY**

```
접수 완료 → 응모 수집 중 → 추첨 진행 → 결과 발표

```

- 상태 설명 문구 자동 변경
    - “현재 대기열에 있습니다”
    - “응모 수집 중입니다 (마감: 18:00)”
    - “추첨이 진행 중입니다”

**핵심 UX 메시지**

> “요청은 즉시 처리되지 않고,
> 
> 
> **이벤트 방식에 맞는 비동기 흐름으로 처리됩니다.”**
> 

---

### 3️) 내 신청 내역 (Participation History)

- 리스트 구성
    - 이벤트명
    - 신청 시각
    - 현재 상태
    - 결과(SUCCESS / REJECTED / PENDING)
- 항목 클릭 시 → 요청 상세 화면 이동
  
### 설계 의도

> 로그인 사용자의 요청을 **장기적으로 추적·보관**하기 위한 허브 화면

---

### 4) 요청 상세 (상태 / 결과 화면)

<aside>


- 요청 상세 화면의 필드(requestedAt/queuedAt/startedAt/finishedAt)는 Request Item의 타임스탬프와 1:1 매핑된다
- 결과 표시는 Request Item의 **`uiResult`**를 기준으로 렌더링
</aside>

- 기본 정보
    - requestId(문의용)
    - eventId
    - requestedAt (신청 시각)
- 상태 타임라인 (시각적)
- 지연 시간 정보(선택 노출)
    - queuedAt (대기열 등록 완료)
    - startedAt (로직 처리 시작)
    - finishedAt (DDB 상태 최종 업데이트한 시각)
- 결과 표시
    - FIRST_COME
        - SUCCESS → “참여 확정”
        - REJECTED → “정원 초과”
    - LOTTERY
        - 마감 전 → “응모 완료 (추첨 대기)”
        - 마감 후 → “당첨 / 미당첨”
- 실패 시
    - 사용자 친화 메시지
    - “문의용 요청 ID 제공”

### 설계 의도

> 비동기 처리의 지연과 결과를 투명하게 노출
> 

---

### 5️) 로그인 / 회원가입

- 이메일 + 비밀번호
- 로그인 후:
    - 신청 내역 영구 보관
    - 상태 조회 가능

**설계 선택 이유**

> 중복 참여 방지, 사용자별 요청 추적,
> 
> 
> 운영·분석 목적의 안정성을 우선
> 

---

## B. 관리자(Admin) 화면 — **4 + 1 (옵션)**

> 관리자 화면은 **백엔드 설계를 시각적으로 증명하는 영역**
> 

### 1️) 운영 대시보드 (Real-time)

- QueueDepth
- ErrorRate
- DLQ Count
- p95 처리 지연
- 상태 배지
    - 정상 / 주의 / 위험

### 메시지

> “현재 시스템이 안정적으로 동작 중인가?”
> 

---

### 2️) 이벤트별 트래픽 / 성공률 분석

- 시간대별 요청량
- SUCCEEDED / REJECTED / FAILED / DLQ 비율
- 이벤트별 비교

### 데이터 출처

> Athena 분석 결과 시각화
> 

---

### 3️) DLQ 목록 + 재처리 제어

- DLQ 메시지 리스트
- 필터
    - Retryable
    - Non-retryable
- 재처리(리드라이브) 버튼
- Runbook 링크 연결

### 운영 설계 강조

> “실패는 숨기지 않고 관리한다”
> 

---

### 4️) 요청 탐색 (Search)

- requestId / userId / eventId 검색
- 상태 전이 로그 타임라인
- 실패 원인 요약

### 목적

> 장애 분석 / 사용자 문의 대응
> 

---

### 5️) (옵션) 이벤트 보호 제어 UI

- 이벤트 임시 중단
- 신규 요청 큐잉 차단
- 기존 처리 유지

Control Plane UX

> “처리 로직은 건드리지 않고
> 
> 
> **수집 단계만 제어**”
> 

---

## 🧭 사용자 흐름 요약 (한 장)

```
로그인
 → 이벤트 선택
 → 참여 클릭
 →202 Accepted (requestId 발급)
 → 상태 자동 갱신
 → 결과 확인
 → 내 신청 내역 저장

```

---

## 상태 갱신 방식 (MVP 기준)

- **Polling**
    - GET /requests/{requestId}
    - 초기 1초 → 2초 → 5초 (지수 백오프)
    - DONE 시 즉시 종료

*(확장)*

- SSE / WebSocket 상태 푸시

---

## 화면에 실제 들어갈 문구 (최종)

### 참여 버튼 아래

- “요청은 즉시 처리되지 않고 접수 후 순서대로 처리됩니다.”
- “접수 완료 후 상태가 자동으로 갱신됩니다.”

### 접수 완료 후

- “접수 완료! 요청 ID: `REQ-XXXX`”
- “중복 신청은 자동으로 차단됩니다.”
- “요청은 안전하게 큐에 보관됩니다.”

### 실패 시

- “일시적인 오류로 처리에 실패했습니다.”
- “요청 ID로 문의하실 수 있습니다.”
- “재시도 가능한 요청은 자동으로 재처리됩니다.”

# Request 상태 머신 — **표준 정의 & UI 매핑표 (최종)**

## 1️) 내부 상태 (백엔드 기준 · 고정)

| 내부 상태 | 의미 | 전이 주체 |
| --- | --- | --- |
| `RECEIVED` | 요청 접수 완료 (Ingest 저장) | Ingest API |
| `QUEUED` | SQS enqueue 완료 | Ingest API |
| `PROCESSING` | Worker 처리 시작 | Worker |
| `SUCCEEDED` | 정상 처리 완료 | Worker |
| `REJECTED` | 정책적 실패 (정원 초과/중복 등) | Worker |
| `FAILED_FINAL` | 재시도 불가 시스템 오류 | Worker |

>  이 상태명은 코드·DB·로그에서만 사용
> 
> 
> (사용자에게 그대로 노출 X)
> 

---

## 2️) 사용자 화면 표시 상태 (UI 전용)

| 내부 상태 | UI 표시 상태 | 사용자 메시지 |
| --- | --- | --- |
| `RECEIVED` | 접수 완료 | “요청이 정상적으로 접수되었습니다.” |
| `QUEUED` | 대기 중 | “현재 대기열에 등록되었습니다.” |
| `PROCESSING` | 처리 중 | “요청을 처리 중입니다.” |
| `SUCCEEDED` | 결과 확정 | “참여가 확정되었습니다.” |
| `REJECTED` | 결과 확정 | “정원 초과로 참여할 수 없습니다.” |
| `FAILED_FINAL` | 처리 실패 | “처리 중 오류가 발생했습니다.” |

**`uiResult`**는 내부 상태와 resultCode를 조합해 백엔드에서 계산하며, 프론트는 이 값을 결과(SUCCESS/REJECTED/PENDING/FAILED) 표시의 단일 기준으로 사용한다.

 **중요 원칙**

- 사용자는 **“왜 아직 결과가 안 나왔는지”**만 알면 됨
- 성공/실패의 **기술적 이유는 숨김**

---

## 3️) 이벤트 방식별 UI 설명 문구 (프론트)

### FIRST_COME (선착순)

| UI 단계 | 표시 문구 |
| --- | --- |
| RECEIVED | “접수가 완료되었습니다.” |
| QUEUED | “선착순 대기열에 등록되었습니다.” |
| PROCESSING | “참여 가능 여부를 확인 중입니다.” |
| SUCCEEDED | “참여가 확정되었습니다.” |
| REJECTED | “정원이 초과되었습니다.” |

---

### LOTTERY (추첨)

>  COLLECTING / DRAWING은 UI 설명 단계
> 
> 
> (백엔드 상태 추가 X)
> 

| 내부 상태 | UI 설명 문구 |
| --- | --- |
| RECEIVED | “응모가 완료되었습니다.” |
| QUEUED | “응모가 수집되고 있습니다.” |
| PROCESSING | “추첨이 진행 중입니다.” |
| SUCCEEDED | “당첨되었습니다” |
| REJECTED | “아쉽게도 미당첨입니다.” |

---

## 4️) 요청 상세 화면 (Request Detail View)

### 기본 정보

- requestId (문의용)
- eventId
- 신청 시각

### 상태 타임라인

```
접수 완료 → 대기 중 → 처리 중 → 결과 확정
```

### 지연 시간 (선택 노출)

- queuedAt
- startedAt
- finishedAt

**UX 메시지**

> “요청은 즉시 처리되지 않으며,
> 
> 
> 대기열을 거쳐 순차적으로 처리됩니다.”
> 

---

## 5️) 실패 메시지 표준 문구 (고정)

### REJECTED (정책적 실패)

- “정원 초과로 참여할 수 없습니다.”
- “중복 신청은 자동으로 차단됩니다.”

### FAILED_FINAL (시스템 오류)

- “일시적인 오류로 처리에 실패했습니다.”
- “요청 ID로 문의하실 수 있습니다.”
- “재시도 가능한 요청은 자동으로 재처리됩니다.”
