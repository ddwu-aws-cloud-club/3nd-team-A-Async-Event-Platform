본 문서는 설계·구현·테스트·운영·발표 전 과정에서

**동일한 개념·용어·규칙을 유지**하기 위한 개발 기준 문서이다.

- 본 문서는 **변경 가능한 가이드가 아니다**
- 코드·PR·테스트·운영 판단의 **최종 기준**으로 사용한다
- 각 단계(G0/G1/G2)는 *기능 추가*가 아니라
    
    **운영 복잡도와 증명 수준을 단계적으로 상승**시키는 과정이다
    

---

## 0. 팀 공통 규칙 (변경 불가 · 설계 고정)

이 섹션은 **코드 리뷰·PR·테스트 기준**으로 사용한다.

---

## 0-1. Request 상태 / 실패 분류 / API 규칙

### Request 상태 (DB 기준 · 고정)

```
RECEIVED
→ QUEUED
→ PROCESSING
→ SUCCEEDED | REJECTED | FAILED_FINAL

```

- 상태는 **Request 단위**로 관리한다.
- `DONE`은 **UI 표현용 개념**이며 DB에 저장하지 않는다.
- LOTTERY의 `COLLECTING / DRAWING`은 **UI phase**로만 표현한다.
- 상태 전이는 **항상 조건부(UpdateItem + ConditionExpression)** 로 수행한다.

---

### 실패 분류 (Worker 기준)

| 분류 | 의미 | 처리 원칙 |
| --- | --- | --- |
| Retryable | 일시 장애 / 네트워크 / 외부 의존성 | 메시지 삭제 ❌ → 재시도 |
| Non-retryable | 정책 위반 / 데이터 오류 | 메시지 삭제 ✅ + FAILED_FINAL |

**📌 DLQ에는 “재시도했으나 끝내 실패한 메시지”만 존재해야 한다.**

---

### API 응답 규칙

| 시나리오 | HTTP | Body |
| --- | --- | --- |
| 최초 참여 | 202 | `{ requestId, isDuplicate:false }` |
| 중복 참여 | 202 | `{ requestId, isDuplicate:true }` |
- 프론트는 **HTTP status가 아니라 requestId 존재만을 기준**으로 동작한다
- 모든 참여 요청은 **항상 requestId를 반환**한다

---

## 0-2. DynamoDB 단일 테이블 원칙

### Table: `AsyncEventTable`

- 단일 테이블
- Billing: `PAY_PER_REQUEST`
- 엔티티 구분은 **PK Prefix로만 수행**

---

### Request Item (핵심 엔티티)

```
PK = REQ#<requestId>
SK = META
```

- 상태 / 타임스탬프 / 결과 / 에러 정보 저장
- **GSI는 Request Item에만 존재** (절대 규칙)

---

### Idempotency Item (중복 차단 전용)

```
PK = IDEMP#<eventId>#<userId>
SK = LOCK
```

- Conditional Put으로 중복 차단
- 이미 존재하면 **기존 requestId 반환**
- TTL은 이벤트 종료 후 +N일

---

### Capacity Item (FIRST_COME 전용)

```
PK = EVENT#<eventId>
SK = CAPACITY
```

- `capacityRemaining > 0` 조건부 감소
- 멀티 워커 환경에서도 **정확히 N명만 성공**

---

## 0-3. 인증/식별 원칙

- `userId`는 **JWT에서만 추출**
- Request Body로 userId 수신 금지
- Debug Header는 **dev 환경에서만 허용**

---

# 1. G0 — Core Flow 구현 단계
(비동기 시스템 “성립” 증명)

## G0의 목표

- 트래픽 폭주 상황에서도 **API는 즉시 응답**
- 요청은 **큐에 적재되고 끝까지 처리**
- 중복 요청이 **단일 requestId로 수렴**
- DLQ와 기본 관측 지표가 실제로 동작

---

## 1-1. 인프라 구성 (G0 범위)

- SQS Main Queue
    - Long Polling 활성화
    - Visibility Timeout ≥ Worker 처리 최대 시간
- SQS DLQ
    - maxReceiveCount 3~5
- DynamoDB `AsyncEventTable`

---

## 1-2. Ingest API (Front Door)

### 엔드포인트

- `POST /events/{eventId}/participations`
- `GET /requests/{requestId}`
- `GET /me/participations`
    - 주의: G0에서는 제한적 Scan 허용
    - G1부터 **GSI1 Query로 전환**

---

### Ingest 처리 순서 (절대 고정)

```
1. IdempotencyLock Conditional Put
2. RequestItem 생성 (RECEIVED)
3. SQS enqueue
4. enqueue 성공 후 QUEUED 전이
5. 응답 반환

```

### 세부 규칙

1️) **IdempotencyLock**

- 실패 시 ❌ 새 requestId 생성 금지
- 저장된 requestId 그대로 반환

2️) **RequestItem 생성**

- `status = RECEIVED`
- `requestedAt = now`

3️) **SQS enqueue**

4️) **enqueue 성공 후에만**

- `status = QUEUED`
- `queuedAt = now` (**공정성 기준 시각**)

5️) **응답**

- 항상 `202 + requestId`

---

### enqueue 실패 처리 정책 (G0 고정)

- RequestItem → `FAILED_FINAL`
- IdempotencyLock 유지 (삭제하지 않음)
- 자동 재시도 X
→ **운영자 판단 하에 재큐잉**

---

## 1-3. Worker 구현 (at-least-once 전제)

### 기본 처리 흐름

1. SQS 메시지 수신
2. 상태 전이
    - `QUEUED → PROCESSING`
    - 조건부 Update (중복 처리 방지)
3. 이벤트 타입 분기
4. 결과 확정
5. 실패 분류에 따른 메시지 처리

---

### FIRST_COME 처리 규칙

- CapacityItem 조건부 Update
- 성공 → SUCCEEDED
- 실패 → REJECTED (CAPACITY)

**동시성 테스트에서 정확히 N건만 성공해야 한다.**

---

### 메시지 삭제 정책

| 처리 결과 | DeleteMessage |
| --- | --- |
| SUCCEEDED / REJECTED | O |
| Retryable 실패 | X |
| Non-retryable 실패 | O |

---

## 1-4. 프론트 G0 연동 기준

- 참여 후 requestId 노출
- 상태 스텝퍼: RECEIVED → QUEUED → PROCESSING → DONE
- 상태 조회는 Polling
- DONE 상태 도달 시 Polling 종료

---

## 1-5. G0 테스트 기준

- 중복 클릭 → 동일 requestId
- Worker 중단 → QueueDepth 증가
- Worker 재기동 → 처리 재개
- k6 200~500 동시 요청
    - API p95 안정
    - QueueDepth 흡수 후 감소

---

# 2. G1 — 관측·분석 증명 단계
(“보인다”를 숫자로 증명)

## G1의 목표

- 처리 과정을 **로그가 아닌 이벤트 데이터로 증명**
- p95 지연·성공률·요청량을 SQL로 산출
- 운영자가 시스템 상태를 설명 가능

---

## 2-1. 이벤트 파이프라인

- EventBridge
- Firehose → S3 (dt/hour)
- Athena

### 이벤트 발행 주체

- Worker (필수)
    - ParticipationProcessed
    - DelayMeasured
    - RequestFailed
- Ingest (선택)
    - ParticipationRequested

---

## 2-2. 지연 모델 (고정)

```
QueueDelay= startedAt - queuedAt
E2EDelay= finishedAt - queuedAt
```

**공정성 기준(queuedAt)을 모든 분석의 기준으로 사용한다.**

---

## 2-3. Athena 필수 산출물

- 시간대별 요청량
- 성공/실패/DLQ 비율
- p95 Queue Delay
- p95 E2E Delay

---

# 3. G2 — 운영 가능성 완성 단계

## G2의 목표

- 스파이크를 **장애가 아닌 지연으로 흡수**
- Worker 처리량 제어
- 알람 / Runbook / DLQ 재처리 실제 동작

---

## 3-1. Worker 스케일링

- ECS Fargate
- QueueDepth 기반 Scale Out
- batch / thread 파라미터화

**목표는 ‘무제한 확장’이 아니라 예측 가능한 처리율(throughput) 유지다.**

---

## 3-2. DLQ 운영

- DLQ 메시지 분류 태그
- Admin에서 조회
- Redrive + Runbook 연계

---

## 3-3. 알람 & 대응

- QueueDepth 임계치
- DLQ 유입
- ErrorRate 급증
- 알람 → Runbook → 조치

---

# 4. Definition of Done (실무 기준)

## G0

- 요청은 항상 빠르게 202
- 상태는 끝까지 전이
- 중복 요청 1회 처리
- DLQ 연결
- 프론트 상태 추적 가능

## G1

- 이벤트 데이터 S3 적재
- Athena 쿼리 결과 확보
- p95 지연 수치 제시 가능

## G2

- 스케일링 동작
- 알람 발생 및 대응 가능
- DLQ 재처리 가능
- 대규모 스파이크에서도 시스템 생존
