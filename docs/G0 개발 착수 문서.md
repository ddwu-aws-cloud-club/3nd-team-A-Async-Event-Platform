# G0 개발 착수 문서

본 문서는 설계, 구현, 코드 리뷰, 테스트, 발표까지 전 과정을 동일한 언어와 기준으로 진행하기 위한 기준 문서다.

G0는 기능 추가를 목표로 하지 않는다.  
G0의 목적은 **비동기 처리 흐름이 실제로 성립함을 증명하는 것**이다.

---

## 1. G0 범위 선언 (고정)

본 문서에서 정의하는 G0의 목표는 아래 세 가지를 증명하는 것이다.

1. 트래픽 상황에서도 API가 즉시 응답한다 (HTTP 202)
2. 중복 요청이 단일 `requestId`로 수렴한다
3. 하나의 `requestId`가 비동기 흐름  
   `RECEIVED → QUEUED → PROCESSING → (SUCCEEDED | REJECTED | FAILED_FINAL)`  
   을 따라 끝까지 추적 가능하다

### 1.1 G0에서 수행하지 않는 범위

아래 항목은 G0 범위에서 구현하거나 완성하지 않는다.

- p95 자동 집계 및 Athena 쿼리 완성
- Worker Auto Scaling
- SSE / WebSocket 기반 실시간 푸시
- 운영 알람 세분화 및 Runbook
- 관리자 UI 완성도

단, **G1/G2 확장을 전제로 구조는 설계한다.**

---

## 2. 인프라 및 DB 환경 구성

### 2.1 DynamoDB: AsyncEventTable (단일 테이블)

- PK/SK 및 GSI1/GSI2 생성
- Billing Mode: PAY_PER_REQUEST
- TTL(옵션): `ttl` (epoch seconds)
- 절대 규칙
  - GSI 필드는 RequestItem에만 존재
  - Idempotency / Capacity / StatusLog에 GSI 필드 존재 금지
- GSI2SK는 불변
  - `QAT#{queuedAt}#REQ#{requestId}`
  - status 포함 금지
- status는 Attribute로만 관리하며, 운영 집계는 서버에서 해석

### 2.2 SQS 구성

- Main Queue
  - Long Polling 활성화
  - Visibility Timeout ≥ Worker 최대 처리 시간
- Dead Letter Queue (DLQ)
  - maxReceiveCount: 3~5
  - Main Queue와 연결

### 2.3 CapacityItem 초기 생성 (테스트 픽스처)

FIRST_COME 공정성 검증을 위한 사전 테스트 데이터

- PK = `EVENT#{eventId}`
- SK = `CAPACITY`
- `capacityTotal`, `capacityRemaining` 설정

---

## 3. G0 개발 단계 개요

G0 개발은 **Step 단위로 진행**하며, 각 Step은 명확한 책임과 완료 조건을 가진다.

---

## Step 0 — 공통 계약 정의 (PR-0, 전원 참여)

### 목적

G0 전체에서 참조하는 **Single Source of Truth**를 먼저 고정한다.  
이 PR이 머지되기 전에는 **다른 작업을 시작하지 않는다.**

### PR-0 대상: `common` 모듈

#### 구현 체크리스트

- `RequestStatus`
  - RECEIVED / QUEUED / PROCESSING / SUCCEEDED / REJECTED / FAILED_FINAL
- `ResultCode`
  - SUCCESS / REJECTED_CAPACITY / FAILED_INGEST_ENQUEUE / …
- `FailureClass`
  - RETRYABLE / NON_RETRYABLE
- `DdbKeyFactory`
  - REQ#, IDEMP#, EVENT#
- `RequestItem`
  - GSI 필드는 RequestItem에만 존재
- `StateTransitionRules`
  - 허용된 상태 전이만 정의
  - 상태 직접 Update 로직 포함 금지

#### 머지 기준

- 문자열 키 하드코딩 금지
- 상태 전이를 common 외부에서 수행 금지

---

## Step 1 — Ingest Core Flow (접수 서버, A 담당)

### 목표

요청을 즉시 처리하지 않고 안정적으로 큐에 적재하고,  
`requestId` 기준으로 추적 가능하게 만든다.

### 핵심 API

`POST /events/{eventId}/participations`

### 처리 순서 (변경 금지)

1. IdempotencyLock 생성

2. RequestItem 생성 (RECEIVED)

3. SQS enqueue

4. enqueue 성공 후 QUEUED 전이

5. 202 응답


### 완료 기준

- 동일 유저 연속 클릭 → requestId 1개
- queuedAt은 정확히 1회만 기록

(이하 IdempotencyLock / RequestItem / enqueue / QUEUED 전이 / 응답 규칙 **원문과 동일**)

---

## Step 2 — Worker 상태 전이 (비동기 처리기, B 담당)

### 목표

at-least-once 메시징 환경에서도 상태가 절대 뒤틀리지 않게 처리한다.

### 구현 체크리스트

- SQS Long Polling
- QUEUED → PROCESSING (조건부)
- PROCESSING → 최종 상태 (조건부)
- Retryable / Non-retryable 분기
- DLQ 동작 확인

### 멱등 규칙

- 상태 전이는 반드시 ConditionExpression 포함
- 이미 최종 상태면 no-op + ack

---

## Step 3 — FIRST_COME 공정성 + Admin 조회 (B + C)

### PR-3A: Capacity (선착순 공정성)

- CapacityItem 조건부 감소
- 정원 초과 시 REJECTED
- Non-retryable, ack 처리

정원 N이면 SUCCEEDED는 반드시 N개여야 한다.

### PR-3B: Admin 조회

- `GET /admin/requests/{requestId}`
- `GET /admin/events/{eventId}/requests`
- GSI2 사용
- 상태 집계는 서버에서 status 기준 처리

---

## 4. G0 Definition of Done

- 요청은 항상 202 Accepted 즉시 반환
- 중복 요청은 단일 requestId
- 상태는 최종 상태까지 전이
- 중복 메시지/재시도 상황에서도 상태 역전 없음
- DLQ 정상 동작
- requestId 기반 Polling 가능

---

## 5. G0 부하 테스트 범위

### 목적

- 빠름이 아니라 **망가지지 않음**을 증명

### 범위

- k6
- 동시 요청 200~500
- 단일 이벤트 기준

### 성공 기준

- API는 항상 202 즉시 반환
- QueueDepth 증가 후 감소
- 일부 requestId가 최종 상태 도달

---

## 요약

G0는 기능 구현 단계가 아니다.  
`requestId` 하나가 끝까지 공정하고, 중복 없이, 추적 가능하면 성공이다.
